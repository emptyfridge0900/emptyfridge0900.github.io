<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta content="width=device-width, initial-scale=1" name="viewport" />
  <meta content="#ffffff" name="theme-color" />
  <meta content="#da532c" name="msapplication-TileColor" />

  
  <link href='&#x2F;icons&#x2F;site.webmanifest' rel="manifest" />
  
  
  <link color="#5bbad5" href='&#x2F;icons&#x2F;safari-pinned-tab.svg' rel="mask-icon" />
  
  
  <link href='&#x2F;icons&#x2F;favicon-16x16.png' rel="icon" sizes="16x16" type="image/png" />
  
  
  <link href='&#x2F;icons&#x2F;favicon-32x32.png' rel="icon" sizes="32x32" type="image/png" />
  
  
  <link href='&#x2F;icons&#x2F;apple-touch-icon.png' rel="apple-touch-icon" sizes="180x180" />
  

  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/galleria@1.6.1/dist/themes/folio/galleria.folio.min.css" integrity="sha384-+rY0QD+LRnTOquDMzGa9lXU6jIwdiQuwCJQ2cdcW0qeP/0UbjQCZlXnRsUMA+9pH" crossorigin="anonymous">
  

  
  <link rel="stylesheet" href="https://api.mapbox.com/mapbox-gl-js/v2.6.1/mapbox-gl.css" integrity="sha384-oGm59HWAkwO32h2w8u0B98wKBZJwd6MbWtAJwQKCTffZjOXHXrnyv9Syjovgc+UV" crossorigin="anonymous">
  

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jpswalsh/academicons@1.9.1/css/academicons.min.css" integrity="sha384-FIue+PI4SsI9XfHCz8dBLg33b0c1fMJgNU3X//L26FYbGnlSEfWmNT7zgWc2N9b6" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link href="https://emptyfridge.dev/deep-thought.css" rel="stylesheet" />
  
  

  <title>
    
 | Middleware

  </title>

  
  
  

  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" integrity="sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs" crossorigin="anonymous">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" integrity="sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx" crossorigin="anonymous"></script>

  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/mathtex-script-type.min.js" integrity="sha384-jiBVvJ8NGGj5n7kJaiWwWp9AjC+Yh8rhZY3GtAX8yU28azcLgoRo4oukO87g7zDT" crossorigin="anonymous"></script>
  
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>
  
  
</head>

<body class="has-background-white">
  <nav aria-label="section navigation" class="navbar is-light" role="navigation">
    <div class="container">
      <div class="navbar-brand">
        <a class="navbar-item is-size-5 has-text-weight-bold" href="https:&#x2F;&#x2F;emptyfridge.dev&#x2F;"></a>
        <a aria-expanded="false" aria-label="menu" class="navbar-burger burger" data-target="navMenu" role="button">
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
        </a>
      </div>
      <div class="navbar-menu" id="navMenu">
        <div class="navbar-end has-text-centered">
          
          
          
          <a class="navbar-item has-text-weight-semibold" href="https:&#x2F;&#x2F;emptyfridge.dev&#x2F;">
            Home
          </a>
          
          <a class="navbar-item has-text-weight-semibold" href="https:&#x2F;&#x2F;emptyfridge.dev&#x2F;&#x2F;data_structure">
            DS
          </a>
          
          <a class="navbar-item has-text-weight-semibold" href="https:&#x2F;&#x2F;emptyfridge.dev&#x2F;&#x2F;algorithm">
            Algo
          </a>
          
          <a class="navbar-item has-text-weight-semibold" href="https:&#x2F;&#x2F;emptyfridge.dev&#x2F;&#x2F;leetcode">
            Coding Practice
          </a>
          
          <a class="navbar-item has-text-weight-semibold" href="https:&#x2F;&#x2F;emptyfridge.dev&#x2F;&#x2F;rust">
            Rust
          </a>
          
          <a class="navbar-item has-text-weight-semibold" href="https:&#x2F;&#x2F;emptyfridge.dev&#x2F;&#x2F;csharp">
            C#
          </a>
          
          <a class="navbar-item has-text-weight-semibold" href="https:&#x2F;&#x2F;emptyfridge.dev&#x2F;&#x2F;projects">
            Toy Projects
          </a>
          
          <a class="navbar-item has-text-weight-semibold" href="https:&#x2F;&#x2F;emptyfridge.dev&#x2F;&#x2F;docker">
            Docker
          </a>
          
          <a class="navbar-item has-text-weight-semibold" href="https:&#x2F;&#x2F;emptyfridge.dev&#x2F;&#x2F;commands">
            Commands
          </a>
          
          <a class="navbar-item has-text-weight-semibold" href="https:&#x2F;&#x2F;emptyfridge.dev&#x2F;&#x2F;rabbitmq">
            RabbitMQ
          </a>
          
          <a class="navbar-item has-text-weight-semibold" href="https:&#x2F;&#x2F;emptyfridge.dev&#x2F;&#x2F;tags">
            Tags
          </a>
          
          <a class="navbar-item has-text-weight-semibold" href="https:&#x2F;&#x2F;emptyfridge.dev&#x2F;&#x2F;categories">
            Categories
          </a>
          
          
          
          <a class="navbar-item" id="nav-search" title="Search" data-target="#search-modal">
            <span class="icon">
              <i class="fas fa-search"></i>
            </span>
          </a>
          <a class="navbar-item" id="dark-mode" title="Switch to dark theme">
            <span class="icon">
              <i class="fas fa-adjust"></i>
            </span>
          </a>
        </div>
      </div>
    </div>
  </nav>

  
  

  
<section class="section">
  <div class="container">
    <div class="columns">
      <div class="column is-8 is-offset-2">
        <article class="box">
          <h1 class="title">
            Middleware
          </h1>
          <p class="subtitle"></p>
          <div class="columns is-multiline is-gapless">
            <div class="column is-8">
              
<span class="icon-text has-text-grey">
  <span class="icon">
    <i class="fas fa-user"></i>
  </span>
  <span>Doosan published on</span>
  <span class="icon">
    <i class="far fa-calendar-alt"></i>
  </span>
  <span><time datetime="2023-09-26">September 26, 2023</time></span>
</span>

            </div>
            <div class="column is-4 has-text-right-desktop">
              
<span class="icon-text has-text-grey">
  <span class="icon">
    <i class="far fa-clock"></i>
  </span>
  <span>4 min,</span>
  <span class="icon">
    <i class="fas fa-pencil-alt"></i>
  </span>
  <span>738 words</span>
</span>

            </div>
            <div class="column">
              
              
<p>
  Categories:
  
  <a class="has-text-info-dark has-text-weight-semibold" href="https://emptyfridge.dev/categories/post/">
    <span class="icon-text">
      <span class="icon">
        <i class="fas fa-cube"></i>
      </span>
      <span>Post</span>
    </span>
  </a>
  
</p>

              
            </div>
            <div class="column has-text-right-desktop">
              
              
<p>
  Tags:
  
  <a class="has-text-info-dark has-text-weight-semibold" href="https://emptyfridge.dev/tags/post/">
    <span class="icon-text">
      <span class="icon">
        <i class="fas fa-tag"></i>
      </span>
      <span>post</span>
    </span>
  </a>
  
  <a class="has-text-info-dark has-text-weight-semibold" href="https://emptyfridge.dev/tags/rust/">
    <span class="icon-text">
      <span class="icon">
        <i class="fas fa-tag"></i>
      </span>
      <span>Rust</span>
    </span>
  </a>
  
</p>

              
            </div>
          </div>
          <div class="content mt-2">
            <p>요즘 axum을 공부하고 있는데 지난 이틀동안은 Service trait가 어떻게 만들어 졌는지 살펴보았다.</p>
<p><a href="https://tokio.rs/blog/2021-05-14-inventing-the-service-trait">링크</a></p>
<p>내가 보기에 편하게 주절주절 써놓은 것이지 위의 아티클을 번역한 건 아니다.</p>
<p>아래와 같은 api가 있다고 치자</p>
<pre data-lang="rs" style="background-color:#383838;color:#e6e1dc;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="color:#95815e;">// Create a server that listens on port 3000
</span><span style="font-style:italic;color:#6e9cbe;">let</span><span> server </span><span style="color:#cc7833;">= </span><span>Server::new(</span><span style="color:#c1be91;">&quot;127.0.0.1:3000&quot;</span><span>).await</span><span style="color:#cc7833;">?</span><span>;
</span><span>
</span><span style="color:#95815e;">// Somehow run the user&#39;s application
</span><span>server.</span><span style="color:#da4939;">run</span><span>(the_users_application).await</span><span style="color:#cc7833;">?</span><span>;
</span></code></pre>
<p>the_users_application은 어떻게 생겼을까?</p>
<pre data-lang="rs" style="background-color:#383838;color:#e6e1dc;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">handle_request</span><span>(</span><span style="font-style:italic;color:#fd971f;">request</span><span>: HttpRequest) -&gt; HttpResponse {
</span><span>    </span><span style="color:#95815e;">// ...
</span><span>}
</span></code></pre>
<p>위에 HttpRequest와 HttpResponse는 Tower 라이브러리에서 제공되는 구조체이다.</p>
<p>run함수는 아래와 같이 생겼을 것이다.</p>
<pre data-lang="rs" style="background-color:#383838;color:#e6e1dc;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="font-style:italic;color:#6e9cbe;">impl </span><span>Server {
</span><span>    async </span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">run</span><span>&lt;F&gt;(</span><span style="font-style:italic;color:#fd971f;">self</span><span>, </span><span style="font-style:italic;color:#fd971f;">handler</span><span>: F) -&gt; </span><span style="font-style:italic;color:#6e9cbe;">Result</span><span>&lt;(), Error&gt;
</span><span>    </span><span style="color:#cc7833;">where
</span><mark style="background-color:#60606080;"><span>        F: Fn(HttpRequest) -&gt; HttpResponse,
</span></mark><span>    {
</span><span>        </span><span style="font-style:italic;color:#6e9cbe;">let</span><span> listener </span><span style="color:#cc7833;">= </span><span>TcpListener::bind(</span><span style="color:#d0d0ff;">self</span><span>.addr).await</span><span style="color:#cc7833;">?</span><span>;
</span><span>
</span><span>        </span><span style="color:#cc7833;">loop </span><span>{
</span><span>            </span><span style="font-style:italic;color:#6e9cbe;">let </span><span style="color:#cc7833;">mut</span><span> connection </span><span style="color:#cc7833;">=</span><span> listener.</span><span style="color:#da4939;">accept</span><span>().await</span><span style="color:#cc7833;">?</span><span>;
</span><span>            </span><span style="font-style:italic;color:#6e9cbe;">let</span><span> request </span><span style="color:#cc7833;">= </span><span style="color:#da4939;">read_http_request</span><span>(</span><span style="color:#cc7833;">&amp;mut</span><span> connection).await</span><span style="color:#cc7833;">?</span><span>;
</span><span>
</span><span>            task::spawn(async </span><span style="color:#cc7833;">move </span><span>{
</span><span>                </span><span style="color:#95815e;">// Call the handler provided by the user
</span><span>                </span><span style="font-style:italic;color:#6e9cbe;">let</span><span> response </span><span style="color:#cc7833;">= </span><span style="color:#da4939;">handler</span><span>(request);
</span><span>
</span><span>                </span><span style="color:#da4939;">write_http_response</span><span>(connection, response).await</span><span style="color:#cc7833;">?</span><span>;
</span><span>            });
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>run함수는 HttpRequest를 받아서 HttpResponse를 return하는 cosure를 파라미터로 받는다.
그럼 handle_request함수는 아래와 같이 구현할 수 있다.</p>
<pre data-lang="rs" style="background-color:#383838;color:#e6e1dc;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">handle_request</span><span>(</span><span style="font-style:italic;color:#fd971f;">request</span><span>: HttpRequest) -&gt; HttpResponse {
</span><span>    </span><span style="color:#95815e;">// ...
</span><span>}
</span><span>
</span><span>↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
</span><span>
</span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">handle_request</span><span>(</span><span style="font-style:italic;color:#fd971f;">request</span><span>: HttpRequest) -&gt; HttpResponse {
</span><span>    </span><span style="color:#cc7833;">if</span><span> request.</span><span style="color:#da4939;">path</span><span>() </span><span style="color:#cc7833;">== </span><span style="color:#c1be91;">&quot;/&quot; </span><span>{
</span><span>        HttpResponse::ok(</span><span style="color:#c1be91;">&quot;Hello, World!&quot;</span><span>)
</span><span>    } </span><span style="color:#cc7833;">else </span><span>{
</span><span>        HttpResponse::not_found()
</span><span>    }
</span><span>}
</span><span>
</span><span>server.</span><span style="color:#da4939;">run</span><span>(handle_request).await</span><span style="color:#cc7833;">?</span><span>;
</span></code></pre>
<p>하지만 우리의 서버는 비동기적으로 요청을 받을 수 없다. 그러니 아래와 같이 바꿔주자</p>
<pre data-lang="rs" style="background-color:#383838;color:#e6e1dc;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="font-style:italic;color:#6e9cbe;">impl </span><span>Server {
</span><span>    async </span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">run</span><span>&lt;F&gt;(</span><span style="font-style:italic;color:#fd971f;">self</span><span>, </span><span style="font-style:italic;color:#fd971f;">handler</span><span>: F) -&gt; </span><span style="font-style:italic;color:#6e9cbe;">Result</span><span>&lt;(), Error&gt;
</span><span>    </span><span style="color:#cc7833;">where
</span><span>        F: Fn(HttpRequest) -&gt; HttpResponse,
</span><span>    {
</span><span>        </span><span style="font-style:italic;color:#6e9cbe;">let</span><span> listener </span><span style="color:#cc7833;">= </span><span>TcpListener::bind(</span><span style="color:#d0d0ff;">self</span><span>.addr).await</span><span style="color:#cc7833;">?</span><span>;
</span><span>
</span><span>        </span><span style="color:#cc7833;">loop </span><span>{
</span><span>            </span><span style="font-style:italic;color:#6e9cbe;">let </span><span style="color:#cc7833;">mut</span><span> connection </span><span style="color:#cc7833;">=</span><span> listener.</span><span style="color:#da4939;">accept</span><span>().await</span><span style="color:#cc7833;">?</span><span>;
</span><span>            </span><span style="font-style:italic;color:#6e9cbe;">let</span><span> request </span><span style="color:#cc7833;">= </span><span style="color:#da4939;">read_http_request</span><span>(</span><span style="color:#cc7833;">&amp;mut</span><span> connection).await</span><span style="color:#cc7833;">?</span><span>;
</span><span>
</span><span>            task::spawn(async </span><span style="color:#cc7833;">move </span><span>{
</span><span>                </span><span style="font-style:italic;color:#6e9cbe;">let</span><span> response </span><span style="color:#cc7833;">= </span><span style="color:#da4939;">handler</span><span>(request);
</span><span>
</span><span>                </span><span style="color:#da4939;">write_http_response</span><span>(connection, response).await</span><span style="color:#cc7833;">?</span><span>;
</span><span>            });
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span>↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
</span><span>
</span><span style="font-style:italic;color:#6e9cbe;">impl </span><span>Server {
</span><span>    async </span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">run</span><span>&lt;F, Fut&gt;(</span><span style="font-style:italic;color:#fd971f;">self</span><span>, </span><span style="font-style:italic;color:#fd971f;">handler</span><span>: F) -&gt; </span><span style="font-style:italic;color:#6e9cbe;">Result</span><span>&lt;(), Error&gt;
</span><span>    </span><span style="color:#cc7833;">where
</span><mark style="background-color:#60606080;"><span>        </span><span style="color:#95815e;">// `handler` now returns a generic type `Fut`...
</span></mark><span>        F: Fn(HttpRequest) -&gt; Fut,
</span><mark style="background-color:#60606080;"><span>        </span><span style="color:#95815e;">// ...which is a `Future` whose `Output` is an `HttpResponse`
</span></mark><span>        Fut: Future&lt;Output = HttpResponse&gt;,
</span><span>    {
</span><span>        </span><span style="font-style:italic;color:#6e9cbe;">let</span><span> listener </span><span style="color:#cc7833;">= </span><span>TcpListener::bind(</span><span style="color:#d0d0ff;">self</span><span>.addr).await</span><span style="color:#cc7833;">?</span><span>;
</span><span>
</span><span>        </span><span style="color:#cc7833;">loop </span><span>{
</span><span>            </span><span style="font-style:italic;color:#6e9cbe;">let </span><span style="color:#cc7833;">mut</span><span> connection </span><span style="color:#cc7833;">=</span><span> listener.</span><span style="color:#da4939;">accept</span><span>().await</span><span style="color:#cc7833;">?</span><span>;
</span><span>            </span><span style="font-style:italic;color:#6e9cbe;">let</span><span> request </span><span style="color:#cc7833;">= </span><span style="color:#da4939;">read_http_request</span><span>(</span><span style="color:#cc7833;">&amp;mut</span><span> connection).await</span><span style="color:#cc7833;">?</span><span>;
</span><span>
</span><span>            task::spawn(async </span><span style="color:#cc7833;">move </span><span>{
</span><span>                </span><span style="color:#95815e;">// Await the future returned by `handler`
</span><span>                </span><span style="font-style:italic;color:#6e9cbe;">let</span><span> response </span><span style="color:#cc7833;">= </span><span style="color:#da4939;">handler</span><span>(request).await;
</span><span>
</span><span>                </span><span style="color:#da4939;">write_http_response</span><span>(connection, response).await</span><span style="color:#cc7833;">?</span><span>;
</span><span>            });
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>서버 파라미터가 바뀌었으니 handle_request도 비동기 처리를 할수 있게되었다</p>
<pre data-lang="rs" style="background-color:#383838;color:#e6e1dc;" class="language-rs "><code class="language-rs" data-lang="rs"><span>
</span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">handle_request</span><span>(</span><span style="font-style:italic;color:#fd971f;">request</span><span>: HttpRequest) -&gt; HttpResponse {
</span><span>    </span><span style="color:#cc7833;">if</span><span> request.</span><span style="color:#da4939;">path</span><span>() </span><span style="color:#cc7833;">== </span><span style="color:#c1be91;">&quot;/&quot; </span><span>{
</span><span>        HttpResponse::ok(</span><span style="color:#c1be91;">&quot;Hello, World!&quot;</span><span>)
</span><span>    } </span><span style="color:#cc7833;">else </span><span>{
</span><span>        HttpResponse::not_found()
</span><span>    }
</span><span>}
</span><span>
</span><span>↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
</span><span>
</span><span>async </span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">handle_request</span><span>(</span><span style="font-style:italic;color:#fd971f;">request</span><span>: HttpRequest) -&gt; HttpResponse {
</span><span>    </span><span style="color:#cc7833;">if</span><span> request.</span><span style="color:#da4939;">path</span><span>() </span><span style="color:#cc7833;">== </span><span style="color:#c1be91;">&quot;/&quot; </span><span>{
</span><span>        HttpResponse::ok(</span><span style="color:#c1be91;">&quot;Hello, World!&quot;</span><span>)
</span><span>    } </span><span style="color:#cc7833;">else if</span><span> request.</span><span style="color:#da4939;">path</span><span>() </span><span style="color:#cc7833;">== </span><span style="color:#c1be91;">&quot;/important-data&quot; </span><span>{
</span><span>        </span><span style="color:#95815e;">// We can now do async stuff in here
</span><span>        </span><span style="font-style:italic;color:#6e9cbe;">let</span><span> some_data </span><span style="color:#cc7833;">= </span><span style="color:#da4939;">fetch_data_from_database</span><span>().await;
</span><span>        </span><span style="color:#da4939;">make_response</span><span>(some_data)
</span><span>    } </span><span style="color:#cc7833;">else </span><span>{
</span><span>        HttpResponse::not_found()
</span><span>    }
</span><span>}
</span></code></pre>
<p>서버의 run함수가 error를 처리할수 있게 한번 더 업그레이드 해주자</p>
<pre data-lang="rs" style="background-color:#383838;color:#e6e1dc;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="font-style:italic;color:#6e9cbe;">impl </span><span>Server {
</span><span>    async </span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">run</span><span>&lt;F, Fut&gt;(</span><span style="font-style:italic;color:#fd971f;">self</span><span>, </span><span style="font-style:italic;color:#fd971f;">handler</span><span>: F) -&gt; </span><span style="font-style:italic;color:#6e9cbe;">Result</span><span>&lt;(), Error&gt;
</span><span>    </span><span style="color:#cc7833;">where
</span><span>        F: Fn(HttpRequest) -&gt; Fut,
</span><span>        Fut: Future&lt;Output = HttpResponse&gt;,
</span><span>    {
</span><span>        </span><span style="font-style:italic;color:#6e9cbe;">let</span><span> listener </span><span style="color:#cc7833;">= </span><span>TcpListener::bind(</span><span style="color:#d0d0ff;">self</span><span>.addr).await</span><span style="color:#cc7833;">?</span><span>;
</span><span>
</span><span>        </span><span style="color:#cc7833;">loop </span><span>{
</span><span>            </span><span style="font-style:italic;color:#6e9cbe;">let </span><span style="color:#cc7833;">mut</span><span> connection </span><span style="color:#cc7833;">=</span><span> listener.</span><span style="color:#da4939;">accept</span><span>().await</span><span style="color:#cc7833;">?</span><span>;
</span><span>            </span><span style="font-style:italic;color:#6e9cbe;">let</span><span> request </span><span style="color:#cc7833;">= </span><span style="color:#da4939;">read_http_request</span><span>(</span><span style="color:#cc7833;">&amp;mut</span><span> connection).await</span><span style="color:#cc7833;">?</span><span>;
</span><span>
</span><span>            task::spawn(async </span><span style="color:#cc7833;">move </span><span>{
</span><span>                </span><span style="font-style:italic;color:#6e9cbe;">let</span><span> response </span><span style="color:#cc7833;">= </span><span style="color:#da4939;">handler</span><span>(request).await;
</span><span>
</span><span>                </span><span style="color:#da4939;">write_http_response</span><span>(connection, response).await</span><span style="color:#cc7833;">?</span><span>;
</span><span>            });
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span>↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
</span><span>
</span><span style="font-style:italic;color:#6e9cbe;">impl </span><span>Server {
</span><span>    async </span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">run</span><span>&lt;F, Fut&gt;(</span><span style="font-style:italic;color:#fd971f;">self</span><span>, </span><span style="font-style:italic;color:#fd971f;">handler</span><span>: F) -&gt; </span><span style="font-style:italic;color:#6e9cbe;">Result</span><span>&lt;(), Error&gt;
</span><span>    </span><span style="color:#cc7833;">where
</span><span>        F: Fn(HttpRequest) -&gt; Fut,
</span><mark style="background-color:#60606080;"><span>        </span><span style="color:#95815e;">// The response future is now allowed to fail
</span></mark><span>        Fut: Future&lt;Output = </span><span style="font-style:italic;color:#6e9cbe;">Result</span><span>&lt;HttpResponse, Error&gt;&gt;,
</span><span>    {
</span><span>        </span><span style="font-style:italic;color:#6e9cbe;">let</span><span> listener </span><span style="color:#cc7833;">= </span><span>TcpListener::bind(</span><span style="color:#d0d0ff;">self</span><span>.addr).await</span><span style="color:#cc7833;">?</span><span>;
</span><span>
</span><span>        </span><span style="color:#cc7833;">loop </span><span>{
</span><span>            </span><span style="font-style:italic;color:#6e9cbe;">let </span><span style="color:#cc7833;">mut</span><span> connection </span><span style="color:#cc7833;">=</span><span> listener.</span><span style="color:#da4939;">accept</span><span>().await</span><span style="color:#cc7833;">?</span><span>;
</span><span>            </span><span style="font-style:italic;color:#6e9cbe;">let</span><span> request </span><span style="color:#cc7833;">= </span><span style="color:#da4939;">read_http_request</span><span>(</span><span style="color:#cc7833;">&amp;mut</span><span> connection).await</span><span style="color:#cc7833;">?</span><span>;
</span><span>
</span><span>            task::spawn(async </span><span style="color:#cc7833;">move </span><span>{
</span><mark style="background-color:#60606080;"><span>                </span><span style="color:#95815e;">// Pattern match on the result of the response future
</span></mark><mark style="background-color:#60606080;"><span>                </span><span style="color:#cc7833;">match </span><span style="color:#da4939;">handler</span><span>(request).await {
</span></mark><mark style="background-color:#60606080;"><span>                    </span><span style="font-style:italic;color:#6e9cbe;">Ok</span><span>(response) </span><span style="color:#cc7833;">=&gt; </span><span style="color:#da4939;">write_http_response</span><span>(connection, response).await</span><span style="color:#cc7833;">?</span><span>,
</span></mark><mark style="background-color:#60606080;"><span>                    </span><span style="font-style:italic;color:#6e9cbe;">Err</span><span>(error) </span><span style="color:#cc7833;">=&gt; </span><span style="color:#da4939;">handle_error_somehow</span><span>(error, connection),
</span></mark><span>                }
</span><span>            });
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<h2 id="gineung-cuga">기능 추가</h2>
<p><em>타임아웃 기능</em>과 그리고 <em>content-type:application/json을 헤더에 추가하는 기능</em>을 추가해보자</p>
<p>handle_request를 사용하는 새로운 handler를 만들자</p>
<pre data-lang="rs" style="background-color:#383838;color:#e6e1dc;" class="language-rs "><code class="language-rs" data-lang="rs"><span>async </span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">handler_with_timeout</span><span>(</span><span style="font-style:italic;color:#fd971f;">request</span><span>: HttpRequest) -&gt; </span><span style="font-style:italic;color:#6e9cbe;">Result</span><span>&lt;HttpResponse, Error&gt; {
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">let</span><span> result </span><span style="color:#cc7833;">= </span><span>tokio::time::timeout(
</span><span>        Duration::from_secs(</span><span style="color:#a5c261;">30</span><span>),
</span><span>        </span><span style="color:#da4939;">handle_request</span><span>(request)
</span><span>    ).await;
</span><span>
</span><span>    </span><span style="color:#cc7833;">match</span><span> result {
</span><span>        </span><span style="font-style:italic;color:#6e9cbe;">Ok</span><span>(</span><span style="font-style:italic;color:#6e9cbe;">Ok</span><span>(response)) </span><span style="color:#cc7833;">=&gt; </span><span style="font-style:italic;color:#6e9cbe;">Ok</span><span>(response),
</span><span>        </span><span style="font-style:italic;color:#6e9cbe;">Ok</span><span>(</span><span style="font-style:italic;color:#6e9cbe;">Err</span><span>(error)) </span><span style="color:#cc7833;">=&gt; </span><span style="font-style:italic;color:#6e9cbe;">Err</span><span>(error),
</span><span>        </span><span style="font-style:italic;color:#6e9cbe;">Err</span><span>(_timeout_elapsed) </span><span style="color:#cc7833;">=&gt; </span><span style="font-style:italic;color:#6e9cbe;">Err</span><span>(Error::timeout()),
</span><span>    }
</span><span>}
</span></code></pre>
<p>그리고 handler_with_timeout을 사용하는 handler를 만들자</p>
<pre data-lang="rs" style="background-color:#383838;color:#e6e1dc;" class="language-rs "><code class="language-rs" data-lang="rs"><span>async </span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">handler_with_timeout_and_content_type</span><span>(
</span><span>    </span><span style="font-style:italic;color:#fd971f;">request</span><span>: HttpRequest,
</span><span>) -&gt; </span><span style="font-style:italic;color:#6e9cbe;">Result</span><span>&lt;HttpResponse, Error&gt; {
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">let </span><span style="color:#cc7833;">mut</span><span> response </span><span style="color:#cc7833;">= </span><span style="color:#da4939;">handler_with_timeout</span><span>(request).await</span><span style="color:#cc7833;">?</span><span>;
</span><span>    response.</span><span style="color:#da4939;">set_header</span><span>(</span><span style="color:#c1be91;">&quot;Content-Type&quot;</span><span>, </span><span style="color:#c1be91;">&quot;application/json&quot;</span><span>);
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">Ok</span><span>(response)
</span><span>}
</span></code></pre>
<p>이 방식은 잘 작동하겠지만 스케일 하기에는 쉽지 않다.
지금은 2개의 handler를 추가 했지만 나중에 몇개의 handler를 더 추가 한다면 handler를 추가할 때마다 중간 핸들러 호출의 체인을 하드 코딩해야 하므로 추가하기 힘들다.</p>
<pre data-lang="rs" style="background-color:#383838;color:#e6e1dc;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="font-style:italic;color:#6e9cbe;">let</span><span> final_handler </span><span style="color:#cc7833;">= </span><span style="color:#da4939;">with_content_type</span><span>(</span><span style="color:#da4939;">with_timeout</span><span>(handle_request));
</span></code></pre>
<p>예를 들어 handler_with_timeout_and_content_type 함수는 handler_with_timeout 함수를 필요로 하고 handler_with_timeout 함수는 handle_request 함수를 필요로 한다. 그래서 엄격하게 순서를 지켜야하는데 이 함수들을 유연하게 compose하는 방법이 없을까?</p>
<pre data-lang="rs" style="background-color:#383838;color:#e6e1dc;" class="language-rs "><code class="language-rs" data-lang="rs"><span>async </span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">handle_request</span><span>&lt;F&gt;(
</span><span>    </span><span style="font-style:italic;color:#fd971f;">fn</span><span>: F
</span><span>) -&gt; impl Fn(HttpRequest) -&gt; impl Future&lt;Output = </span><span style="font-style:italic;color:#6e9cbe;">Result</span><span>&lt;HttpResponse, Error&gt;&gt; 
</span><span style="color:#cc7833;">where
</span><span>    F: Fn(HttpRequest) -&gt; Future&lt;Output = </span><span style="font-style:italic;color:#6e9cbe;">Result</span><span>&lt;HttpResponse, Error&gt;&gt;
</span><span>{
</span><span>}
</span></code></pre>
<p>이런 핸들러를 쓸 수 있다면 좋을텐데 rust에서는 안된다. 특히 impl Fn() -&gt; impl Future 는 불가능하다.
Box를 사용해서 리턴할수는 있지만 퍼포먼스가 느려져서 배제한다.</p>
<h3 id="handler-trait">Handler trait</h3>
<p>Server::run이 F: Fn(HttpRequest) -&gt; Fut 클로저를 받아들이게 하지 말고 async fn(HttpRequest) -&gt; Result&lt;HttpResponse, Error&gt; 을 캡슐화 하는 Trait를 만들자</p>
<pre data-lang="rs" style="background-color:#383838;color:#e6e1dc;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="font-style:italic;color:#6e9cbe;">impl </span><span>Server {
</span><span>    async </span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">run</span><span>&lt;F, Fut&gt;(</span><span style="font-style:italic;color:#fd971f;">self</span><span>, </span><span style="font-style:italic;color:#fd971f;">handler</span><span>: F) -&gt; </span><span style="font-style:italic;color:#6e9cbe;">Result</span><span>&lt;(), Error&gt;
</span><span>    </span><span style="color:#cc7833;">where
</span><span>        F: Fn(HttpRequest) -&gt; Fut,
</span><span>        Fut: Future&lt;Output = </span><span style="font-style:italic;color:#6e9cbe;">Result</span><span>&lt;HttpResponse, Error&gt;&gt;,
</span><span>    {
</span><span>        </span><span style="font-style:italic;color:#6e9cbe;">let</span><span> listener </span><span style="color:#cc7833;">= </span><span>TcpListener::bind(</span><span style="color:#d0d0ff;">self</span><span>.addr).await</span><span style="color:#cc7833;">?</span><span>;
</span><span>
</span><span>        </span><span style="color:#cc7833;">loop </span><span>{
</span><span>            </span><span style="font-style:italic;color:#6e9cbe;">let </span><span style="color:#cc7833;">mut</span><span> connection </span><span style="color:#cc7833;">=</span><span> listener.</span><span style="color:#da4939;">accept</span><span>().await</span><span style="color:#cc7833;">?</span><span>;
</span><span>            </span><span style="font-style:italic;color:#6e9cbe;">let</span><span> request </span><span style="color:#cc7833;">= </span><span style="color:#da4939;">read_http_request</span><span>(</span><span style="color:#cc7833;">&amp;mut</span><span> connection).await</span><span style="color:#cc7833;">?</span><span>;
</span><span>
</span><span>            task::spawn(async </span><span style="color:#cc7833;">move </span><span>{
</span><span>                </span><span style="color:#cc7833;">match </span><span style="color:#da4939;">handler</span><span>(request).await {
</span><span>                    </span><span style="font-style:italic;color:#6e9cbe;">Ok</span><span>(response) </span><span style="color:#cc7833;">=&gt; </span><span style="color:#da4939;">write_http_response</span><span>(connection, response).await</span><span style="color:#cc7833;">?</span><span>,
</span><span>                    </span><span style="font-style:italic;color:#6e9cbe;">Err</span><span>(error) </span><span style="color:#cc7833;">=&gt; </span><span style="color:#da4939;">handle_error_somehow</span><span>(error, connection),
</span><span>                }
</span><span>            });
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span>↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
</span><span>
</span><span style="font-style:italic;color:#6e9cbe;">impl </span><span>Server {
</span><mark style="background-color:#60606080;"><span>    async </span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">run</span><span>&lt;T&gt;(</span><span style="font-style:italic;color:#fd971f;">self</span><span>, </span><span style="color:#cc7833;">mut </span><span style="font-style:italic;color:#fd971f;">handler</span><span>: T) -&gt; </span><span style="font-style:italic;color:#6e9cbe;">Result</span><span>&lt;(), Error&gt;
</span></mark><span>    </span><span style="color:#cc7833;">where
</span><mark style="background-color:#60606080;"><span>        T: Handler,
</span></mark><span>    {
</span><span>        </span><span style="font-style:italic;color:#6e9cbe;">let</span><span> listener </span><span style="color:#cc7833;">= </span><span>TcpListener::bind(</span><span style="color:#d0d0ff;">self</span><span>.addr).await</span><span style="color:#cc7833;">?</span><span>;
</span><span>
</span><span>        </span><span style="color:#cc7833;">loop </span><span>{
</span><span>            </span><span style="font-style:italic;color:#6e9cbe;">let </span><span style="color:#cc7833;">mut</span><span> connection </span><span style="color:#cc7833;">=</span><span> listener.</span><span style="color:#da4939;">accept</span><span>().await</span><span style="color:#cc7833;">?</span><span>;
</span><span>            </span><span style="font-style:italic;color:#6e9cbe;">let</span><span> request </span><span style="color:#cc7833;">= </span><span style="color:#da4939;">read_http_request</span><span>(</span><span style="color:#cc7833;">&amp;mut</span><span> connection).await</span><span style="color:#cc7833;">?</span><span>;
</span><span>
</span><span>            task::spawn(async </span><span style="color:#cc7833;">move </span><span>{
</span><span>                </span><span style="color:#95815e;">// have to call `Handler::call` here
</span><span>                </span><span style="color:#cc7833;">match</span><span> handler.</span><span style="color:#da4939;">call</span><span>(request).await {
</span><span>                    </span><span style="font-style:italic;color:#6e9cbe;">Ok</span><span>(response) </span><span style="color:#cc7833;">=&gt; </span><span style="color:#da4939;">write_http_response</span><span>(connection, response).await</span><span style="color:#cc7833;">?</span><span>,
</span><span>                    </span><span style="font-style:italic;color:#6e9cbe;">Err</span><span>(error) </span><span style="color:#cc7833;">=&gt; </span><span style="color:#da4939;">handle_error_somehow</span><span>(error, connection),
</span><span>                }
</span><span>            });
</span><span>        }
</span><span>    }
</span><span>}
</span><span style="font-style:italic;color:#6e9cbe;">trait </span><span>Handler {
</span><span>    async </span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">call</span><span>(</span><span style="color:#cc7833;">&amp;mut </span><span style="font-style:italic;color:#fd971f;">self</span><span>, </span><span style="font-style:italic;color:#fd971f;">request</span><span>: HttpRequest) -&gt; </span><span style="font-style:italic;color:#6e9cbe;">Result</span><span>&lt;HttpResponse, Error&gt;;
</span><span>}
</span></code></pre>
<p>하지만 rust는 async 매소드를 가진 trait를 지원하지 않아서</p>
<ol>
<li>Pin&lt;Box&lt;dyn Future&lt;Output = Result&lt;HttpResponse, Error&gt;&gt;&gt; 을 리턴하는 매소드</li>
<li>type Future을 associated type으로 가지는 Handler
둘중 하나의 방식을 택할 수 있다.</li>
</ol>
<p>두번째 방식으로 하자</p>
<pre data-lang="rs" style="background-color:#383838;color:#e6e1dc;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="font-style:italic;color:#6e9cbe;">trait </span><span>Handler {
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">type </span><span>Future: Future&lt;Output = </span><span style="font-style:italic;color:#6e9cbe;">Result</span><span>&lt;HttpResponse, Error&gt;&gt;;
</span><span>
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">call</span><span>(</span><span style="color:#cc7833;">&amp;mut </span><span style="font-style:italic;color:#fd971f;">self</span><span>, </span><span style="font-style:italic;color:#fd971f;">request</span><span>: HttpRequest) -&gt; </span><span style="font-style:italic;color:#6e9cbe;">Self::</span><span>Future;
</span><span>}
</span></code></pre>
<p>기존의 handle_request 함수를 Handler trait로 바꿔주자</p>
<pre data-lang="rs" style="background-color:#383838;color:#e6e1dc;" class="language-rs "><code class="language-rs" data-lang="rs"><span>async </span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">handle_request</span><span>(</span><span style="font-style:italic;color:#fd971f;">request</span><span>: HttpRequest) -&gt; HttpResponse {
</span><span>    </span><span style="color:#cc7833;">if</span><span> request.</span><span style="color:#da4939;">path</span><span>() </span><span style="color:#cc7833;">== </span><span style="color:#c1be91;">&quot;/&quot; </span><span>{
</span><span>        HttpResponse::ok(</span><span style="color:#c1be91;">&quot;Hello, World!&quot;</span><span>)
</span><span>    } </span><span style="color:#cc7833;">else if</span><span> request.</span><span style="color:#da4939;">path</span><span>() </span><span style="color:#cc7833;">== </span><span style="color:#c1be91;">&quot;/important-data&quot; </span><span>{
</span><span>        </span><span style="font-style:italic;color:#6e9cbe;">let</span><span> some_data </span><span style="color:#cc7833;">= </span><span style="color:#da4939;">fetch_data_from_database</span><span>().await;
</span><span>        </span><span style="color:#da4939;">make_response</span><span>(some_data)
</span><span>    } </span><span style="color:#cc7833;">else </span><span>{
</span><span>        HttpResponse::not_found()
</span><span>    }
</span><span>}
</span><span>
</span><span>↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
</span><span>
</span><span style="font-style:italic;color:#6e9cbe;">struct </span><span>RequestHandler;
</span><span>
</span><span style="font-style:italic;color:#6e9cbe;">impl </span><span>Handler </span><span style="color:#cc7833;">for </span><span>RequestHandler {
</span><span>    </span><span style="color:#95815e;">// We use `Pin&lt;Box&lt;...&gt;&gt;` here for simplicity, but could also define our
</span><span>    </span><span style="color:#95815e;">// own `Future` type to avoid the overhead
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">type </span><span>Future </span><span style="color:#cc7833;">= </span><span>Pin&lt;</span><span style="font-style:italic;color:#6e9cbe;">Box</span><span>&lt;dyn Future&lt;Output = </span><span style="font-style:italic;color:#6e9cbe;">Result</span><span>&lt;HttpResponse, Error&gt;&gt;&gt;&gt;;
</span><span>
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">call</span><span>(</span><span style="color:#cc7833;">&amp;mut </span><span style="font-style:italic;color:#fd971f;">self</span><span>, </span><span style="font-style:italic;color:#fd971f;">request</span><span>: HttpRequest) -&gt; </span><span style="font-style:italic;color:#6e9cbe;">Self::</span><span>Future {
</span><span>        </span><span style="font-style:italic;color:#6e9cbe;">Box</span><span>::pin(async </span><span style="color:#cc7833;">move </span><span>{
</span><span>            </span><span style="color:#95815e;">// same implementation as we had before
</span><span>            </span><span style="color:#cc7833;">if</span><span> request.</span><span style="color:#da4939;">path</span><span>() </span><span style="color:#cc7833;">== </span><span style="color:#c1be91;">&quot;/&quot; </span><span>{
</span><span>                </span><span style="font-style:italic;color:#6e9cbe;">Ok</span><span>(HttpResponse::ok(</span><span style="color:#c1be91;">&quot;Hello, World!&quot;</span><span>))
</span><span>            } </span><span style="color:#cc7833;">else if</span><span> request.</span><span style="color:#da4939;">path</span><span>() </span><span style="color:#cc7833;">== </span><span style="color:#c1be91;">&quot;/important-data&quot; </span><span>{
</span><span>                </span><span style="font-style:italic;color:#6e9cbe;">let</span><span> some_data </span><span style="color:#cc7833;">= </span><span style="color:#da4939;">fetch_data_from_database</span><span>().await</span><span style="color:#cc7833;">?</span><span>;
</span><span>                </span><span style="font-style:italic;color:#6e9cbe;">Ok</span><span>(</span><span style="color:#da4939;">make_response</span><span>(some_data))
</span><span>            } </span><span style="color:#cc7833;">else </span><span>{
</span><span>                </span><span style="font-style:italic;color:#6e9cbe;">Ok</span><span>(HttpResponse::not_found())
</span><span>            }
</span><span>        })
</span><span>    }
</span><span>}
</span></code></pre>
<h3 id="timeout-handler">Timeout Handler</h3>
<pre data-lang="rs" style="background-color:#383838;color:#e6e1dc;" class="language-rs "><code class="language-rs" data-lang="rs"><span>async </span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">handler_with_timeout</span><span>(</span><span style="font-style:italic;color:#fd971f;">request</span><span>: HttpRequest) -&gt; </span><span style="font-style:italic;color:#6e9cbe;">Result</span><span>&lt;HttpResponse, Error&gt; {
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">let</span><span> result </span><span style="color:#cc7833;">= </span><span>tokio::time::timeout(
</span><span>        Duration::from_secs(</span><span style="color:#a5c261;">30</span><span>),
</span><span>        </span><span style="color:#da4939;">handle_request</span><span>(request)
</span><span>    ).await;
</span><span>
</span><span>    </span><span style="color:#cc7833;">match</span><span> result {
</span><span>        </span><span style="font-style:italic;color:#6e9cbe;">Ok</span><span>(</span><span style="font-style:italic;color:#6e9cbe;">Ok</span><span>(response)) </span><span style="color:#cc7833;">=&gt; </span><span style="font-style:italic;color:#6e9cbe;">Ok</span><span>(response),
</span><span>        </span><span style="font-style:italic;color:#6e9cbe;">Ok</span><span>(</span><span style="font-style:italic;color:#6e9cbe;">Err</span><span>(error)) </span><span style="color:#cc7833;">=&gt; </span><span style="font-style:italic;color:#6e9cbe;">Err</span><span>(error),
</span><span>        </span><span style="font-style:italic;color:#6e9cbe;">Err</span><span>(_timeout_elapsed) </span><span style="color:#cc7833;">=&gt; </span><span style="font-style:italic;color:#6e9cbe;">Err</span><span>(Error::timeout()),
</span><span>    }
</span><span>}
</span><span>
</span><span>↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
</span><span>
</span><span style="font-style:italic;color:#6e9cbe;">struct </span><span>Timeout&lt;T&gt; {
</span><span>    </span><span style="color:#95815e;">// T will be some type that implements `Handler`
</span><span>    </span><span style="color:#d0d0ff;">inner_handler</span><span>: T,
</span><span>    </span><span style="color:#d0d0ff;">duration</span><span>: Duration,
</span><span>}
</span><span>
</span><span style="font-style:italic;color:#6e9cbe;">impl</span><span>&lt;T&gt; Handler </span><span style="color:#cc7833;">for </span><span>Timeout&lt;T&gt;
</span><span style="color:#cc7833;">where
</span><span>    T: Handler,
</span><span>{
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">type </span><span>Future </span><span style="color:#cc7833;">= </span><span>Pin&lt;</span><span style="font-style:italic;color:#6e9cbe;">Box</span><span>&lt;dyn Future&lt;Output = </span><span style="font-style:italic;color:#6e9cbe;">Result</span><span>&lt;HttpResponse, Error&gt;&gt;&gt;&gt;;
</span><span>
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">call</span><span>(</span><span style="color:#cc7833;">&amp;mut </span><span style="font-style:italic;color:#fd971f;">self</span><span>, </span><span style="font-style:italic;color:#fd971f;">request</span><span>: HttpRequest) -&gt; </span><span style="font-style:italic;color:#6e9cbe;">Self::</span><span>Future {
</span><span>        </span><span style="font-style:italic;color:#6e9cbe;">Box</span><span>::pin(async </span><span style="color:#cc7833;">move </span><span>{
</span><span>            </span><span style="font-style:italic;color:#6e9cbe;">let</span><span> result </span><span style="color:#cc7833;">= </span><span>tokio::time::timeout(
</span><span>                </span><span style="color:#d0d0ff;">self</span><span>.duration,
</span><span>                </span><span style="color:#d0d0ff;">self</span><span>.inner_handler.</span><span style="color:#da4939;">call</span><span>(request),
</span><span>            ).await;
</span><span>
</span><span>            </span><span style="color:#cc7833;">match</span><span> result {
</span><span>                </span><span style="font-style:italic;color:#6e9cbe;">Ok</span><span>(</span><span style="font-style:italic;color:#6e9cbe;">Ok</span><span>(response)) </span><span style="color:#cc7833;">=&gt; </span><span style="font-style:italic;color:#6e9cbe;">Ok</span><span>(response),
</span><span>                </span><span style="font-style:italic;color:#6e9cbe;">Ok</span><span>(</span><span style="font-style:italic;color:#6e9cbe;">Err</span><span>(error)) </span><span style="color:#cc7833;">=&gt; </span><span style="font-style:italic;color:#6e9cbe;">Err</span><span>(error),
</span><span>                </span><span style="font-style:italic;color:#6e9cbe;">Err</span><span>(_timeout) </span><span style="color:#cc7833;">=&gt; </span><span style="font-style:italic;color:#6e9cbe;">Err</span><span>(Error::timeout()),
</span><span>            }
</span><span>        })
</span><span>    }
</span><span>}
</span></code></pre>
<p>컴파일 에러가 뜰것이다</p>
<pre data-lang="rs" style="background-color:#383838;color:#e6e1dc;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="color:#a5c261;">144 </span><span style="color:#cc7833;">|       </span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">call</span><span>(</span><span style="color:#cc7833;">&amp;mut </span><span style="font-style:italic;color:#fd971f;">self</span><span>, </span><span style="font-style:italic;color:#fd971f;">request</span><span>: HttpRequest) -&gt; </span><span style="font-style:italic;color:#6e9cbe;">Self::</span><span>Future {
</span><span>    </span><span style="color:#cc7833;">|               ---------</span><span> this data with an anonymous lifetime `</span><span style="color:#cc7833;">&#39;_</span><span>`</span><span style="color:#cc7833;">...
</span><span style="color:#a5c261;">145 </span><span style="color:#cc7833;">|           </span><span style="font-style:italic;color:#6e9cbe;">Box</span><span>::pin(async </span><span style="color:#cc7833;">move </span><span>{
</span><span>    |  _____________________________^
</span><span style="color:#a5c261;">146 </span><span style="color:#cc7833;">| |             </span><span style="font-style:italic;color:#6e9cbe;">let</span><span> result </span><span style="color:#cc7833;">= </span><span>tokio::time::timeout(
</span><span style="color:#a5c261;">147 </span><span style="color:#cc7833;">| |                 </span><span style="color:#d0d0ff;">self</span><span>.duration,
</span><span style="color:#a5c261;">148 </span><span style="color:#cc7833;">| |                 </span><span style="color:#d0d0ff;">self</span><span>.inner_handler.</span><span style="color:#da4939;">call</span><span>(request),
</span><span style="color:#cc7833;">...   |
</span><span style="color:#a5c261;">155 </span><span style="color:#cc7833;">| |</span><span>             }
</span><span style="color:#a5c261;">156 </span><span style="color:#cc7833;">| |</span><span>         })
</span><span>    </span><span style="color:#cc7833;">| |</span><span style="color:#6d9cbe;">_________</span><span style="color:#cc7833;">^ ...</span><span>is captured here, requiring it to live </span><span style="color:#cc7833;">as</span><span> long </span><span style="color:#cc7833;">as</span><span> `</span><span style="color:#cc7833;">&#39;static</span><span>`
</span></code></pre>
<p>self가 async block으로 빨려들어가서 lifetime이 끝까지 살아남지 못해서 생긴 에러</p>
<p>trait bound에 clone을 추가해주자</p>
<pre data-lang="rs" style="background-color:#383838;color:#e6e1dc;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="font-style:italic;color:#6e9cbe;">impl</span><span>&lt;T&gt; Handler </span><span style="color:#cc7833;">for </span><span>Timeout&lt;T&gt;
</span><span style="color:#cc7833;">where
</span><mark style="background-color:#60606080;"><span>    T: Handler + Clone,
</span></mark></code></pre>
<p>그래도 에러가 뜬다.
컴파일러가 말하길 static lifetime이 필요하다고 한다</p>
<pre data-lang="rs" style="background-color:#383838;color:#e6e1dc;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="color:#a5c261;">140 </span><span style="color:#cc7833;">|   </span><span style="font-style:italic;color:#6e9cbe;">impl</span><span>&lt;T&gt; Handler </span><span style="color:#cc7833;">for </span><span>Timeout&lt;T&gt;
</span><span>    |        - help: consider adding an explicit lifetime bound...: `T: </span><span style="color:#cc7833;">&#39;static</span><span>`
</span><span>...
</span><span>149 | /         Box::pin(async move {
</span><span style="color:#a5c261;">150 </span><span style="color:#cc7833;">| |             </span><span style="font-style:italic;color:#6e9cbe;">let</span><span> result </span><span style="color:#cc7833;">= </span><span>tokio::time::timeout(
</span><span style="color:#a5c261;">151 </span><span style="color:#cc7833;">| |</span><span>                 this.duration,
</span><span style="color:#a5c261;">152 </span><span style="color:#cc7833;">| |</span><span>                 this.inner_handler.</span><span style="color:#da4939;">call</span><span>(request),
</span><span style="color:#cc7833;">...   |
</span><span style="color:#a5c261;">159 </span><span style="color:#cc7833;">| |</span><span>             }
</span><span style="color:#a5c261;">160 </span><span style="color:#cc7833;">| |</span><span>         })
</span><span>    </span><span style="color:#cc7833;">| |</span><span style="color:#6d9cbe;">__________</span><span style="color:#cc7833;">^ ...</span><span>so that the </span><span style="font-style:italic;color:#6e9cbe;">type</span><span> `</span><span style="font-style:italic;color:#6e9cbe;">impl </span><span>Future` will meet its required lifetime bounds
</span></code></pre>
<p>'static을 추가해주자. 이제 컴파일 잘 된다</p>
<pre data-lang="rs" style="background-color:#383838;color:#e6e1dc;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="font-style:italic;color:#6e9cbe;">impl</span><span>&lt;T&gt; Handler </span><span style="color:#cc7833;">for </span><span>Timeout&lt;T&gt;
</span><span style="color:#cc7833;">where
</span><mark style="background-color:#60606080;"><span>    T: Handler + Clone + </span><span style="color:#cc7833;">&#39;static</span><span>,
</span></mark></code></pre>
<h3 id="content-type-handler">Content-Type Handler</h3>
<p>T Type에 Clone, 'static 추가해주는걸 잊지말자</p>
<pre data-lang="rs" style="background-color:#383838;color:#e6e1dc;" class="language-rs "><code class="language-rs" data-lang="rs"><span>#[derive(Clone)]
</span><span style="font-style:italic;color:#6e9cbe;">struct </span><span>JsonContentType&lt;T&gt; {
</span><span>    </span><span style="color:#d0d0ff;">inner_handler</span><span>: T,
</span><span>}
</span><span>
</span><span>↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
</span><span>
</span><mark style="background-color:#60606080;"><span style="font-style:italic;color:#6e9cbe;">impl</span><span>&lt;T&gt; Handler </span><span style="color:#cc7833;">for </span><span>JsonContentType&lt;T&gt;
</span></mark><span style="color:#cc7833;">where
</span><span>    T: Handler + Clone + </span><span style="color:#cc7833;">&#39;static</span><span>,
</span><span>{
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">type </span><span>Future </span><span style="color:#cc7833;">= </span><span>Pin&lt;</span><span style="font-style:italic;color:#6e9cbe;">Box</span><span>&lt;dyn Future&lt;Output = </span><span style="font-style:italic;color:#6e9cbe;">Result</span><span>&lt;HttpResponse, Error&gt;&gt;&gt;&gt;;
</span><span>
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">call</span><span>(</span><span style="color:#cc7833;">&amp;mut </span><span style="font-style:italic;color:#fd971f;">self</span><span>, </span><span style="font-style:italic;color:#fd971f;">request</span><span>: HttpRequest) -&gt; </span><span style="font-style:italic;color:#6e9cbe;">Self::</span><span>Future {
</span><span>        </span><span style="font-style:italic;color:#6e9cbe;">let </span><span style="color:#cc7833;">mut</span><span> this </span><span style="color:#cc7833;">= </span><span style="color:#d0d0ff;">self</span><span>.</span><span style="color:#da4939;">clone</span><span>();
</span><span>
</span><span>        </span><span style="font-style:italic;color:#6e9cbe;">Box</span><span>::pin(async </span><span style="color:#cc7833;">move </span><span>{
</span><span>            </span><span style="font-style:italic;color:#6e9cbe;">let </span><span style="color:#cc7833;">mut</span><span> response </span><span style="color:#cc7833;">=</span><span> this.inner_handler.</span><span style="color:#da4939;">call</span><span>(request).await</span><span style="color:#cc7833;">?</span><span>;
</span><span>            response.</span><span style="color:#da4939;">set_header</span><span>(</span><span style="color:#c1be91;">&quot;Content-Type&quot;</span><span>, </span><span style="color:#c1be91;">&quot;application/json&quot;</span><span>);
</span><span>            </span><span style="font-style:italic;color:#6e9cbe;">Ok</span><span>(response)
</span><span>        })
</span><span>    }
</span><span>}
</span></code></pre>
<p>이제는 hadler들을 합성하기에 수월해졌다</p>
<pre data-lang="rs" style="background-color:#383838;color:#e6e1dc;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="font-style:italic;color:#6e9cbe;">let</span><span> handler </span><span style="color:#cc7833;">=</span><span> RequestHandler;
</span><span style="font-style:italic;color:#6e9cbe;">let</span><span> handler </span><span style="color:#cc7833;">= </span><span>Timeout::new(handler, Duration::from_secs(</span><span style="color:#a5c261;">30</span><span>));
</span><span style="font-style:italic;color:#6e9cbe;">let</span><span> handler </span><span style="color:#cc7833;">= </span><span>JsonContentType::new(handler);
</span><span>
</span><span style="color:#95815e;">// `handler` has type `JsonContentType&lt;Timeout&lt;RequestHandler&gt;&gt;`
</span><span>
</span><span>server.</span><span style="color:#da4939;">run</span><span>(handler).await
</span></code></pre>
<h2 id="handlerreul-deo-yuyeonhage">Handler를 더 유연하게...</h2>
<p>우리의 handler는 현재 HttpRequest만 다룰 수있다. 좀더 generic한 handler를 만들어보자</p>
<pre data-lang="rs" style="background-color:#383838;color:#e6e1dc;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="font-style:italic;color:#6e9cbe;">trait </span><span>Handler {
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">type </span><span>Future: Future&lt;Output = </span><span style="font-style:italic;color:#6e9cbe;">Result</span><span>&lt;HttpResponse, Error&gt;&gt;;
</span><span>
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">call</span><span>(</span><span style="color:#cc7833;">&amp;mut </span><span style="font-style:italic;color:#fd971f;">self</span><span>, </span><span style="font-style:italic;color:#fd971f;">request</span><span>: HttpRequest) -&gt; </span><span style="font-style:italic;color:#6e9cbe;">Self::</span><span>Future;
</span><span>}
</span><span>
</span><span>↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
</span><span>
</span><span style="font-style:italic;color:#6e9cbe;">trait </span><span>Handler&lt;Request&gt; {
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">type </span><span>Response;
</span><span>
</span><span>    </span><span style="color:#95815e;">// Error should also be an associated type. No reason for that to be a
</span><span>    </span><span style="color:#95815e;">// hardcoded type
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">type </span><span>Error;
</span><span>
</span><span>    </span><span style="color:#95815e;">// Our future type from before, but now it&#39;s output must use
</span><span>    </span><span style="color:#95815e;">// the associated `Response` and `Error` types
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">type </span><span>Future: Future&lt;Output = </span><span style="font-style:italic;color:#6e9cbe;">Result</span><span>&lt;</span><span style="font-style:italic;color:#6e9cbe;">Self::</span><span>Response, </span><span style="font-style:italic;color:#6e9cbe;">Self::</span><span>Error&gt;&gt;;
</span><span>
</span><span>    </span><span style="color:#95815e;">// `call` is unchanged, but note that `Request` here is our generic
</span><span>    </span><span style="color:#95815e;">// `Request` type parameter and not the `HttpRequest` type we&#39;ve used
</span><span>    </span><span style="color:#95815e;">// until now
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">call</span><span>(</span><span style="color:#cc7833;">&amp;mut </span><span style="font-style:italic;color:#fd971f;">self</span><span>, </span><span style="font-style:italic;color:#fd971f;">request</span><span>: Request) -&gt; </span><span style="font-style:italic;color:#6e9cbe;">Self::</span><span>Future;
</span><span>}
</span></code></pre>
<h3 id="request-handler">Request Handler</h3>
<pre data-lang="rs" style="background-color:#383838;color:#e6e1dc;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="font-style:italic;color:#6e9cbe;">impl </span><span>Handler </span><span style="color:#cc7833;">for </span><span>RequestHandler {
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">type </span><span>Future </span><span style="color:#cc7833;">= </span><span>Pin&lt;</span><span style="font-style:italic;color:#6e9cbe;">Box</span><span>&lt;dyn Future&lt;Output = </span><span style="font-style:italic;color:#6e9cbe;">Result</span><span>&lt;HttpResponse, Error&gt;&gt;&gt;&gt;;
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">call</span><span>(</span><span style="color:#cc7833;">&amp;mut </span><span style="font-style:italic;color:#fd971f;">self</span><span>, </span><span style="font-style:italic;color:#fd971f;">request</span><span>: HttpRequest) -&gt; </span><span style="font-style:italic;color:#6e9cbe;">Self::</span><span>Future {
</span><span>    }
</span><span>}
</span><span>
</span><span>↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
</span><span>
</span><span style="font-style:italic;color:#6e9cbe;">impl </span><span>Handler&lt;HttpRequest&gt; </span><span style="color:#cc7833;">for </span><span>RequestHandler {
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">type </span><span>Response </span><span style="color:#cc7833;">=</span><span> HttpResponse;
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">type </span><span>Error </span><span style="color:#cc7833;">=</span><span> Error;
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">type </span><span>Future </span><span style="color:#cc7833;">= </span><span>Pin&lt;</span><span style="font-style:italic;color:#6e9cbe;">Box</span><span>&lt;dyn Future&lt;Output = </span><span style="font-style:italic;color:#6e9cbe;">Result</span><span>&lt;HttpResponse, Error&gt;&gt;&gt;&gt;;
</span><span>
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">call</span><span>(</span><span style="color:#cc7833;">&amp;mut </span><span style="font-style:italic;color:#fd971f;">self</span><span>, </span><span style="font-style:italic;color:#fd971f;">request</span><span>: Request) -&gt; </span><span style="font-style:italic;color:#6e9cbe;">Self::</span><span>Future {
</span><span>        </span><span style="color:#95815e;">// same as before
</span><span>    }
</span><span>}
</span></code></pre>
<h3 id="timeout-handler-1">Timeout Handler</h3>
<p>타임아웃 핸들러는 좀 다르다. 다른 핸들러를 감싸고 있고 비동기 timeout도 추가했기 때문이다.
감싸고 있는 핸들러가 같은 타입을 가지고 있는한 요청과 응답 타입에는 신경쓰지 않아도 된다.</p>
<p>에러타입은 좀 다르다. tokio::time::timeout은 Result&lt;T, tokio::time::error::Elapsed&gt; 을 리턴한다
우리는 tokio::time::error::Elapsed 타입을 내부 핸들러의 에러타입(T::Error)으로 변환해야한다</p>
<pre data-lang="rs" style="background-color:#383838;color:#e6e1dc;" class="language-rs "><code class="language-rs" data-lang="rs"><span>
</span><span style="font-style:italic;color:#6e9cbe;">impl</span><span>&lt;T&gt; Handler </span><span style="color:#cc7833;">for </span><span>Timeout&lt;T&gt;
</span><span style="color:#cc7833;">where
</span><span>    T: Handler,
</span><span>{
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">type </span><span>Future </span><span style="color:#cc7833;">= </span><span>Pin&lt;</span><span style="font-style:italic;color:#6e9cbe;">Box</span><span>&lt;dyn Future&lt;Output = </span><span style="font-style:italic;color:#6e9cbe;">Result</span><span>&lt;HttpResponse, Error&gt;&gt;&gt;&gt;;
</span><span>
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">call</span><span>(</span><span style="color:#cc7833;">&amp;mut </span><span style="font-style:italic;color:#fd971f;">self</span><span>, </span><span style="font-style:italic;color:#fd971f;">request</span><span>: HttpRequest) -&gt; </span><span style="font-style:italic;color:#6e9cbe;">Self::</span><span>Future {
</span><span>        </span><span style="font-style:italic;color:#6e9cbe;">Box</span><span>::pin(async </span><span style="color:#cc7833;">move </span><span>{
</span><span>            </span><span style="font-style:italic;color:#6e9cbe;">let</span><span> result </span><span style="color:#cc7833;">= </span><span>tokio::time::timeout(
</span><span>                </span><span style="color:#d0d0ff;">self</span><span>.duration,
</span><span>                </span><span style="color:#d0d0ff;">self</span><span>.inner_handler.</span><span style="color:#da4939;">call</span><span>(request),
</span><span>            ).await;
</span><span>
</span><span>            </span><span style="color:#cc7833;">match</span><span> result {
</span><span>                </span><span style="font-style:italic;color:#6e9cbe;">Ok</span><span>(</span><span style="font-style:italic;color:#6e9cbe;">Ok</span><span>(response)) </span><span style="color:#cc7833;">=&gt; </span><span style="font-style:italic;color:#6e9cbe;">Ok</span><span>(response),
</span><span>                </span><span style="font-style:italic;color:#6e9cbe;">Ok</span><span>(</span><span style="font-style:italic;color:#6e9cbe;">Err</span><span>(error)) </span><span style="color:#cc7833;">=&gt; </span><span style="font-style:italic;color:#6e9cbe;">Err</span><span>(error),
</span><span>                </span><span style="font-style:italic;color:#6e9cbe;">Err</span><span>(_timeout) </span><span style="color:#cc7833;">=&gt; </span><span style="font-style:italic;color:#6e9cbe;">Err</span><span>(Error::timeout()),
</span><span>            }
</span><span>        })
</span><span>    }
</span><span>}
</span><span>
</span><span>↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
</span><span>
</span><span style="font-style:italic;color:#6e9cbe;">impl</span><span>&lt;R, T&gt; Handler&lt;R&gt; </span><span style="color:#cc7833;">for </span><span>Timeout&lt;T&gt;
</span><span style="color:#cc7833;">where
</span><span>    </span><span style="color:#95815e;">// The actual type of request must not contain
</span><span>    </span><span style="color:#95815e;">// references. The compiler would tell us to add
</span><span>    </span><span style="color:#95815e;">// this if we didn&#39;t
</span><span>    R: </span><span style="color:#cc7833;">&#39;static</span><span>,
</span><span>    </span><span style="color:#95815e;">// `T` must accept requests of type `R`
</span><span>    T: Handler&lt;R&gt; + Clone + </span><span style="color:#cc7833;">&#39;static</span><span>,
</span><span>    </span><span style="color:#95815e;">// We must be able to convert an `Elapsed` into
</span><span>    </span><span style="color:#95815e;">// `T`&#39;s error type
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">T::</span><span>Error: </span><span style="font-style:italic;color:#6e9cbe;">From</span><span>&lt;tokio::time::error::Elapsed&gt;,
</span><span>{
</span><span>    </span><span style="color:#95815e;">// Our response type is the same as `T`&#39;s, since we
</span><span>    </span><span style="color:#95815e;">// don&#39;t have to modify it
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">type </span><span>Response </span><span style="color:#cc7833;">= </span><span>T::Response;
</span><span>
</span><span>    </span><span style="color:#95815e;">// Error type is also the same
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">type </span><span>Error </span><span style="color:#cc7833;">= </span><span>T::Error;
</span><span>
</span><span>    </span><span style="color:#95815e;">// Future must output a `Result` with the correct types
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">type </span><span>Future </span><span style="color:#cc7833;">= </span><span>Pin&lt;</span><span style="font-style:italic;color:#6e9cbe;">Box</span><span>&lt;dyn Future&lt;Output = </span><span style="font-style:italic;color:#6e9cbe;">Result</span><span>&lt;</span><span style="font-style:italic;color:#6e9cbe;">T::</span><span>Response, </span><span style="font-style:italic;color:#6e9cbe;">T::</span><span>Error&gt;&gt;&gt;&gt;;
</span><span>
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">call</span><span>(</span><span style="color:#cc7833;">&amp;mut </span><span style="font-style:italic;color:#fd971f;">self</span><span>, </span><span style="font-style:italic;color:#fd971f;">request</span><span>: R) -&gt; </span><span style="font-style:italic;color:#6e9cbe;">Self::</span><span>Future {
</span><span>        </span><span style="font-style:italic;color:#6e9cbe;">let </span><span style="color:#cc7833;">mut</span><span> this </span><span style="color:#cc7833;">= </span><span style="color:#d0d0ff;">self</span><span>.</span><span style="color:#da4939;">clone</span><span>();
</span><span>
</span><span>        </span><span style="font-style:italic;color:#6e9cbe;">Box</span><span>::pin(async </span><span style="color:#cc7833;">move </span><span>{
</span><span>            </span><span style="font-style:italic;color:#6e9cbe;">let</span><span> result </span><span style="color:#cc7833;">= </span><span>tokio::time::timeout(
</span><span>                this.duration,
</span><span>                this.inner_handler.</span><span style="color:#da4939;">call</span><span>(request),
</span><span>            ).await;
</span><span>
</span><span>            </span><span style="color:#cc7833;">match</span><span> result {
</span><span>                </span><span style="font-style:italic;color:#6e9cbe;">Ok</span><span>(</span><span style="font-style:italic;color:#6e9cbe;">Ok</span><span>(response)) </span><span style="color:#cc7833;">=&gt; </span><span style="font-style:italic;color:#6e9cbe;">Ok</span><span>(response),
</span><span>                </span><span style="font-style:italic;color:#6e9cbe;">Ok</span><span>(</span><span style="font-style:italic;color:#6e9cbe;">Err</span><span>(error)) </span><span style="color:#cc7833;">=&gt; </span><span style="font-style:italic;color:#6e9cbe;">Err</span><span>(error),
</span><span>                </span><span style="font-style:italic;color:#6e9cbe;">Err</span><span>(elapsed) </span><span style="color:#cc7833;">=&gt; </span><span>{
</span><span>                    </span><span style="color:#95815e;">// Convert the error
</span><span>                    </span><span style="font-style:italic;color:#6e9cbe;">Err</span><span>(T::Error::from(elapsed))
</span><span>                }
</span><span>            }
</span><span>        })
</span><span>    }
</span><span>}
</span></code></pre>
<h3 id="content-type-handler-1">Content-Type Handler</h3>
<p>JsonContentType Handler도 앞의 두 핸들러와는 좀 다르다. 요청과 에러 타입에 대해서는 신경 안쓰지만 응답 타입에 대해서는 신경써야한다.
응답 타입은 반드시 set_header를 콜 할수 있는 타입이여야 한다.</p>
<pre data-lang="rs" style="background-color:#383838;color:#e6e1dc;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="font-style:italic;color:#6e9cbe;">impl</span><span>&lt;T&gt; Handler </span><span style="color:#cc7833;">for </span><span>JsonContentType&lt;T&gt;
</span><span style="color:#cc7833;">where
</span><span>    T: Handler + Clone + </span><span style="color:#cc7833;">&#39;static</span><span>,
</span><span>{
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">type </span><span>Future </span><span style="color:#cc7833;">= </span><span>Pin&lt;</span><span style="font-style:italic;color:#6e9cbe;">Box</span><span>&lt;dyn Future&lt;Output = </span><span style="font-style:italic;color:#6e9cbe;">Result</span><span>&lt;HttpResponse, Error&gt;&gt;&gt;&gt;;
</span><span>
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">call</span><span>(</span><span style="color:#cc7833;">&amp;mut </span><span style="font-style:italic;color:#fd971f;">self</span><span>, </span><span style="font-style:italic;color:#fd971f;">request</span><span>: HttpRequest) -&gt; </span><span style="font-style:italic;color:#6e9cbe;">Self::</span><span>Future {
</span><span>        </span><span style="font-style:italic;color:#6e9cbe;">let </span><span style="color:#cc7833;">mut</span><span> this </span><span style="color:#cc7833;">= </span><span style="color:#d0d0ff;">self</span><span>.</span><span style="color:#da4939;">clone</span><span>();
</span><span>
</span><span>        </span><span style="font-style:italic;color:#6e9cbe;">Box</span><span>::pin(async </span><span style="color:#cc7833;">move </span><span>{
</span><span>            </span><span style="font-style:italic;color:#6e9cbe;">let </span><span style="color:#cc7833;">mut</span><span> response </span><span style="color:#cc7833;">=</span><span> this.inner_handler.</span><span style="color:#da4939;">call</span><span>(request).await</span><span style="color:#cc7833;">?</span><span>;
</span><span>            response.</span><span style="color:#da4939;">set_header</span><span>(</span><span style="color:#c1be91;">&quot;Content-Type&quot;</span><span>, </span><span style="color:#c1be91;">&quot;application/json&quot;</span><span>);
</span><span>            </span><span style="font-style:italic;color:#6e9cbe;">Ok</span><span>(response)
</span><span>        })
</span><span>    }
</span><span>}
</span><span>
</span><span>↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
</span><span>
</span><span style="font-style:italic;color:#6e9cbe;">impl</span><span>&lt;R, T&gt; Handler&lt;R&gt; </span><span style="color:#cc7833;">for </span><span>JsonContentType&lt;T&gt;
</span><span style="color:#cc7833;">where
</span><span>    R: </span><span style="color:#cc7833;">&#39;static</span><span>,
</span><span>    </span><span style="color:#95815e;">// `T` must accept requests of any type `R` and return
</span><span>    </span><span style="color:#95815e;">// responses of type `HttpResponse`
</span><span>    T: Handler&lt;R, Response = HttpResponse&gt; + Clone + </span><span style="color:#cc7833;">&#39;static</span><span>,
</span><span>{
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">type </span><span>Response </span><span style="color:#cc7833;">=</span><span> HttpResponse;
</span><span>
</span><span>    </span><span style="color:#95815e;">// Our error type is whatever `T`&#39;s error type is
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">type </span><span>Error </span><span style="color:#cc7833;">= </span><span>T::Error;
</span><span>
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">type </span><span>Future </span><span style="color:#cc7833;">= </span><span>Pin&lt;</span><span style="font-style:italic;color:#6e9cbe;">Box</span><span>&lt;dyn Future&lt;Output = </span><span style="font-style:italic;color:#6e9cbe;">Result</span><span>&lt;Response, </span><span style="font-style:italic;color:#6e9cbe;">T::</span><span>Error&gt;&gt;&gt;&gt;;
</span><span>
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">call</span><span>(</span><span style="color:#cc7833;">&amp;mut </span><span style="font-style:italic;color:#fd971f;">self</span><span>, </span><span style="font-style:italic;color:#fd971f;">request</span><span>: R) -&gt; </span><span style="font-style:italic;color:#6e9cbe;">Self::</span><span>Future {
</span><span>        </span><span style="font-style:italic;color:#6e9cbe;">let </span><span style="color:#cc7833;">mut</span><span> this </span><span style="color:#cc7833;">= </span><span style="color:#d0d0ff;">self</span><span>.</span><span style="color:#da4939;">clone</span><span>();
</span><span>
</span><span>        </span><span style="font-style:italic;color:#6e9cbe;">Box</span><span>::pin(async </span><span style="color:#cc7833;">move </span><span>{
</span><span>            </span><span style="font-style:italic;color:#6e9cbe;">let </span><span style="color:#cc7833;">mut</span><span> response </span><span style="color:#cc7833;">=</span><span> this.inner_handler.</span><span style="color:#da4939;">call</span><span>(request).await</span><span style="color:#cc7833;">?</span><span>;
</span><span>            response.</span><span style="color:#da4939;">set_header</span><span>(</span><span style="color:#c1be91;">&quot;Content-Type&quot;</span><span>, </span><span style="color:#c1be91;">&quot;application/json&quot;</span><span>);
</span><span>            </span><span style="font-style:italic;color:#6e9cbe;">Ok</span><span>(response)
</span><span>        })
</span><span>    }
</span><span>}
</span></code></pre>
<pre data-lang="rs" style="background-color:#383838;color:#e6e1dc;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="font-style:italic;color:#6e9cbe;">impl </span><span>Server {
</span><span>    async </span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">run</span><span>&lt;T&gt;(</span><span style="font-style:italic;color:#fd971f;">self</span><span>, </span><span style="color:#cc7833;">mut </span><span style="font-style:italic;color:#fd971f;">handler</span><span>: T) -&gt; </span><span style="font-style:italic;color:#6e9cbe;">Result</span><span>&lt;(), Error&gt;
</span><span>    </span><span style="color:#cc7833;">where
</span><span>        T: Handler,
</span><span>    {
</span><span>
</span><span>    }
</span><span>}
</span><span>
</span><span>↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
</span><span>
</span><span style="font-style:italic;color:#6e9cbe;">impl </span><span>Server {
</span><span>    async </span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">run</span><span>&lt;T&gt;(</span><span style="font-style:italic;color:#fd971f;">self</span><span>, </span><span style="color:#cc7833;">mut </span><span style="font-style:italic;color:#fd971f;">handler</span><span>: T) -&gt; </span><span style="font-style:italic;color:#6e9cbe;">Result</span><span>&lt;(), Error&gt;
</span><span>    </span><span style="color:#cc7833;">where
</span><span>        T: Handler&lt;HttpRequest, Response = HttpResponse&gt;,
</span><span>    {
</span><span>        </span><span style="color:#95815e;">// ...
</span><span>    }
</span><span>}
</span></code></pre>
<h2 id="service-traityi-deungjang">Service trait의 등장</h2>
<p>Handler trait는 server에서도 client에서도 사용될 수 있다. server, client 둘다 사용 될 수 있기 때문에 Handler 라는 이름은 부적절하다. client는 요청을 handle하지 않기 때문이다. 그러니 Handler대신 Service라고 부르자</p>
<pre data-lang="rs" style="background-color:#383838;color:#e6e1dc;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="font-style:italic;color:#6e9cbe;">trait </span><span>Handler&lt;Request&gt; {
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">type </span><span>Response;
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">type </span><span>Error;
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">type </span><span>Future: Future&lt;Output = </span><span style="font-style:italic;color:#6e9cbe;">Result</span><span>&lt;</span><span style="font-style:italic;color:#6e9cbe;">Self::</span><span>Response, </span><span style="font-style:italic;color:#6e9cbe;">Self::</span><span>Error&gt;&gt;;
</span><span>
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">call</span><span>(</span><span style="color:#cc7833;">&amp;mut </span><span style="font-style:italic;color:#fd971f;">self</span><span>, </span><span style="font-style:italic;color:#fd971f;">request</span><span>: Request) -&gt; </span><span style="font-style:italic;color:#6e9cbe;">Self::</span><span>Future;
</span><span>}
</span><span>
</span><span>↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
</span><span>
</span><span style="font-style:italic;color:#6e9cbe;">trait </span><span>Service&lt;Request&gt; {
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">type </span><span>Response;
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">type </span><span>Error;
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">type </span><span>Future: Future&lt;Output = </span><span style="font-style:italic;color:#6e9cbe;">Result</span><span>&lt;</span><span style="font-style:italic;color:#6e9cbe;">Self::</span><span>Response, </span><span style="font-style:italic;color:#6e9cbe;">Self::</span><span>Error&gt;&gt;;
</span><span>
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">call</span><span>(</span><span style="color:#cc7833;">&amp;mut </span><span style="font-style:italic;color:#fd971f;">self</span><span>, </span><span style="font-style:italic;color:#fd971f;">request</span><span>: Request) -&gt; </span><span style="font-style:italic;color:#6e9cbe;">Self::</span><span>Future;
</span><span>}
</span></code></pre>
<p>이것은 Tower에서 정의하는 Service trait에 근접했다. Tower에서는 이미 구현되있는 Timout, Retry, RateLimit 같은 service들이 존재한다.</p>
<p>Timeout 과 JsonContentType 같은 타입을 middleware라고 부른다. 얘들은 다른 service를 감싸기 때문. Request Handler같은 타입은 leaf service라고 부른다. 중첩된 서비스들 중 말단에 위치해있기 때문이다. 응답은 leaf service에서 생성되고 변조는 middleware에서 일어난다.</p>
<h2 id="baeab">배압</h2>
<p>배압은 생성하는 속도를 소모하는 속도가 못 따라갈때 일어난다.
동시 처리하는 요청의 최대 값을 설정 하는 rate limit middleware을 만든다고 생각해보자. 처리할수 있는 부하의 양의 상한선을 지켜주는 서비스가 있으면 좋을 것이다.</p>
<pre data-lang="rs" style="background-color:#383838;color:#e6e1dc;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="font-style:italic;color:#6e9cbe;">impl</span><span>&lt;R, T&gt; Service&lt;R&gt; </span><span style="color:#cc7833;">for </span><span>ConcurrencyLimit&lt;T&gt; {
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">call</span><span>(</span><span style="color:#cc7833;">&amp;mut </span><span style="font-style:italic;color:#fd971f;">self</span><span>, </span><span style="font-style:italic;color:#fd971f;">request</span><span>: R) -&gt; </span><span style="font-style:italic;color:#6e9cbe;">Self::</span><span>Future {
</span><span>        </span><span style="color:#95815e;">// 1. Check a counter for the number of requests currently being
</span><span>        </span><span style="color:#95815e;">//    processed.
</span><span>        </span><span style="color:#95815e;">// 2. If there is capacity left send the request to `T`
</span><span>        </span><span style="color:#95815e;">//    and increment the counter.
</span><span>        </span><span style="color:#95815e;">// 3. If not somehow wait until capacity becomes available.
</span><span>        </span><span style="color:#95815e;">// 4. When the response has been produced, decrement the counter.
</span><span>    }
</span><span>}
</span></code></pre>
<p>정원이 차면 자리가 빌때까지 기다려야하는데 요청을 메모리에 대기 시키기 때문에 메모리 손실이 일어남.</p>
<p>이러한 method가 있으면 요청을 줄세워 놓은 필요가 없음.</p>
<pre data-lang="rs" style="background-color:#383838;color:#e6e1dc;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="font-style:italic;color:#6e9cbe;">trait </span><span>Service&lt;R&gt; {
</span><span>    async </span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">ready</span><span>(</span><span style="color:#cc7833;">&amp;mut </span><span style="font-style:italic;color:#fd971f;">self</span><span>);
</span><span>}
</span></code></pre>
<p>service.call(request).await 하기 전에 service.ready().await 로 자리가 있는지 확인하면 메모리를 아낄수 있다.</p>
<p>하지만 async 함수를 trait에서 사용하지 못한다. ReadyFuture 이라는 associated type을 하나 더 추가하는 방법도 생각해볼 수 있지만 Future를 리턴하면 예전과 같은 lifetime 문제를 야기할수 있다. 우리는 Future trai에서 아이디어를 얻을 수 있다. 바로 poll_ready 함수를 사용하는 것이다.</p>
<pre data-lang="rs" style="background-color:#383838;color:#e6e1dc;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="color:#cc7833;">use </span><span>std::task::{Context, Poll};
</span><span>
</span><span style="font-style:italic;color:#6e9cbe;">trait </span><span>Service&lt;R&gt; {
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">poll_ready</span><span>(</span><span style="color:#cc7833;">&amp;mut </span><span style="font-style:italic;color:#fd971f;">self</span><span>, </span><span style="font-style:italic;color:#fd971f;">cx</span><span>: </span><span style="color:#cc7833;">&amp;mut </span><span>Context&lt;&#39;</span><span style="color:#cc7833;">_</span><span>&gt;) -&gt; Poll&lt;()&gt;;
</span><span>}
</span></code></pre>
<p>만약 서비스가 수용량이 부족하면 poll_ready가 Poll::Pending을 리턴하고 caller에게 capacity가 다시 가능하게 되면 Context의 waker를 사용하여 통지한다.
poll_ready가 Future를 리턴하지 않는다는 말은 우리는 기다리지 않고 신속하게 ready 상태를 체크할수 있다는 말이다. 만약 우리가 poll_ready를 부르고 Poll::Pending을 리턴받으면, 기다리는 대신 다른 일을 하기로 결정할 수도 있다. 무엇보다도 이것은 서비스가 얼마나 자주 Poll::Pending을 리턴하는지 평가해서 load balancer를 만들수 있게 해준다.
이런식으로 caller와 capacity에 대해 소통하는 것을 backpressure propagation이라고 한다. caller한테 요청이 너무 많으니 좀 줄이라고 말하는 것과 같다. 다른 방법으로 backpressure를 다루는 방법은 buffering, load shedding 이 있다.</p>
<p>마지막으로 capacity 예비를 하는 동안 에러가 발생할 수 있으므로 poll_ready 는 Poll&lt;Result&lt;(), Self::Error&gt;&gt; 를 리턴해야 할 것이다.</p>
<pre data-lang="rs" style="background-color:#383838;color:#e6e1dc;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="font-style:italic;color:#6e9cbe;">trait </span><span>Service&lt;Request&gt; {
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">type </span><span>Response;
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">type </span><span>Error;
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">type </span><span>Future: Future&lt;Output = </span><span style="font-style:italic;color:#6e9cbe;">Result</span><span>&lt;</span><span style="font-style:italic;color:#6e9cbe;">Self::</span><span>Response, </span><span style="font-style:italic;color:#6e9cbe;">Self::</span><span>Error&gt;&gt;;
</span><span>
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">call</span><span>(</span><span style="color:#cc7833;">&amp;mut </span><span style="font-style:italic;color:#fd971f;">self</span><span>, </span><span style="font-style:italic;color:#fd971f;">request</span><span>: Request) -&gt; </span><span style="font-style:italic;color:#6e9cbe;">Self::</span><span>Future;
</span><span>}
</span><span>
</span><span>↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
</span><span>
</span><span style="color:#cc7833;">pub </span><span style="font-style:italic;color:#6e9cbe;">trait </span><span>Service&lt;Request&gt; {
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">type </span><span>Response;
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">type </span><span>Error;
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">type </span><span>Future: Future&lt;Output = </span><span style="font-style:italic;color:#6e9cbe;">Result</span><span>&lt;</span><span style="font-style:italic;color:#6e9cbe;">Self::</span><span>Response, </span><span style="font-style:italic;color:#6e9cbe;">Self::</span><span>Error&gt;&gt;;
</span><span>
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">poll_ready</span><span>(
</span><span>        </span><span style="color:#cc7833;">&amp;mut </span><span style="font-style:italic;color:#fd971f;">self</span><span>,
</span><span>        </span><span style="font-style:italic;color:#fd971f;">cx</span><span>: </span><span style="color:#cc7833;">&amp;mut </span><span>Context&lt;&#39;</span><span style="color:#cc7833;">_</span><span>&gt;,
</span><span>    ) -&gt; Poll&lt;</span><span style="font-style:italic;color:#6e9cbe;">Result</span><span>&lt;(), </span><span style="font-style:italic;color:#6e9cbe;">Self::</span><span>Error&gt;&gt;;
</span><span>
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">call</span><span>(</span><span style="color:#cc7833;">&amp;mut </span><span style="font-style:italic;color:#fd971f;">self</span><span>, </span><span style="font-style:italic;color:#fd971f;">req</span><span>: Request) -&gt; </span><span style="font-style:italic;color:#6e9cbe;">Self::</span><span>Future;
</span><span>}
</span></code></pre>
<p>이렇게 tower의 Service trait가 완성되었다.</p>
<p>많은 middleware들이 자신만의 backpresure를 추가 하지 않고 자기가 감싸고 있는 service의 poll_ready 의 구현을 가져다 쓴다. 하지만 middleware에서의 backpressure는 의미있는 사용법들이 있다. 예를 들어 rate limiting, load balancing, 그리고 auto scaling등이다.</p>
<p>마지막으로 아래는 service를 사용하는 제일 흔한방법이다</p>
<pre data-lang="rs" style="background-color:#383838;color:#e6e1dc;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="color:#cc7833;">use </span><span>tower::{
</span><span>    Service,
</span><span>    </span><span style="color:#95815e;">// for the `ready` method
</span><span>    ServiceExt,
</span><span>};
</span><span>
</span><span style="font-style:italic;color:#6e9cbe;">let</span><span> response </span><span style="color:#cc7833;">=</span><span> service
</span><span>    </span><span style="color:#95815e;">// wait for the service to have capacity
</span><span>    .</span><span style="color:#da4939;">ready</span><span>().await</span><span style="color:#cc7833;">?
</span><span>    </span><span style="color:#95815e;">// send the request
</span><span>    .</span><span style="color:#da4939;">call</span><span>(request).await</span><span style="color:#cc7833;">?</span><span>;
</span></code></pre>

          </div>
        </article>
      </div>
      
    </div>
  </div>
</section>


  
  <section class="modal" id="search-modal">
    <div class="modal-background"></div>
    <div class="modal-card">
      <header class="modal-card-head">
        <p class="modal-card-title">Search</p>
      </header>
      <section class="modal-card-body">
        <div class="field mb-2">
          <div class="control">
            <input class="input" id="search" placeholder="Search this website." type="search" />
          </div>
        </div>
        <div class="search-results">
          <div class="search-results__items"></div>
        </div>
      </section>
    </div>
    <button aria-label="close" class="modal-close is-large"></button>
  </section>
  


  

<section class="section">
  <div class="container">
    <div class="columns is-centered">
      <div class="column is-8">
        <nav class="level">
              
          <div class="level-item has-text-centered">
            <a class="button is-black is-outlined" href="https:&#x2F;&#x2F;emptyfridge.dev&#x2F;rust&#x2F;dyn-impl&#x2F;">
              <span class="icon mr-2">
                <i class="fas fa-arrow-circle-left"></i>
              </span>
              dyn and impl
            </a>
          </div>
           
          <div class="level-item has-text-centered">
            <a class="button is-black is-outlined" href="https:&#x2F;&#x2F;emptyfridge.dev&#x2F;rust&#x2F;closure-lifetime&#x2F;">
              Closure lifetime<span class="icon ml-2">
                <i class="fas fa-arrow-circle-right"></i>
              </span>
            </a>
          </div>
          
        </nav>
      </div>
    </div>
  </div>
</section>



  



  
  <footer class="footer py-4">
    <div class="content has-text-centered">
      <p>
        Built with
        <span class="icon-text">
          <span class="icon">
            <i class="fas fa-code"></i>
          </span>
          <span>code</span>
        </span>
        and
        <span class="icon-text">
          <span class="icon">
            <i class="fas fa-heart"></i>
          </span>
          <span>love</span>
        </span>
      </p>
      <p>
        Powered by
        <span class="icon-text">
          <span class="icon">
            <i class="fas fa-power-off"></i>
          </span>
          <span>zola</span>
        </span>
      </p>
    </div>
  </footer>
  

  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/galleria@1.6.1/dist/galleria.min.js" integrity="sha384-QSfwGT8/EU536DKdtyP2D6SLlh8zBaZ0cVkwfrwhqzIU9VCfJT00CLVP5t+HAiYg" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/galleria@1.6.1/dist/themes/folio/galleria.folio.min.js" integrity="sha384-DwpKI+deZB267+hPKwiOIc5Y2GKsVL0mR6hgz7GgIu7AgAMYqJwcJKY1YBNfhWcY" crossorigin="anonymous"></script>
  
  
  
  
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.6.1/mapbox-gl.js" integrity="sha384-Pulw7+h73841BQIK0LzJCydKRPChJUF9w8h8W0o3h+cLtoyNPJS847bQauLWOTwg" crossorigin="anonymous"></script>
  
  <script src="https://emptyfridge.dev/elasticlunr.min.js"></script>
  <script src="https://emptyfridge.dev/search_index.en.js"></script><script src="https://emptyfridge.dev/js/site.js"></script>

  





  
  
</body>

</html>
