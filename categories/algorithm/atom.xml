<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title> - Algorithm</title>
    <link rel="self" type="application/atom+xml" href="https://emptyfridge.dev/categories/algorithm/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://emptyfridge.dev/"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2025-01-09T00:00:00+00:00</updated>
    <id>https://emptyfridge.dev/categories/algorithm/atom.xml</id>
    <entry xml:lang="en">
        <title>Euclidean Algorithm (유클리드 호제법)</title>
        <published>2025-01-09T00:00:00+00:00</published>
        <updated>2025-01-09T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://emptyfridge.dev/algorithm/euclidean/"/>
        <id>https://emptyfridge.dev/algorithm/euclidean/</id>
        
        <content type="html" xml:base="https://emptyfridge.dev/algorithm/euclidean/">&lt;p&gt;Leet code문제를 풀다 Greatest Common Divisor of Strings이라는 문제를 만났다. 처음에는 아무생각 없이 문자열 두개를 포인터를 써서 비교해가는 방법으로 풀었는데 곧 이 방법은 틀렸다는 것을 알았다. 역시 풀기전에 문제를 잘 읽고 분석을...&lt;&#x2F;p&gt;
&lt;p&gt;핵심은 공통된 최대의 문자열을 찾는 것. 최대 공약 문자열 찾는 방법을 문자열의 길이로 바꾸면? 그렇다, 그냥 최대공약수 찾기 문제인것이다.&lt;&#x2F;p&gt;
&lt;p&gt;최대공약수 찾기를 구현해본적이 없어서 혼자 이리저리 생각해 보았는데 결국은 다른 사람의 도움을 받기로 했다. 그리고 정말 깔끔한 코들를 발견했다&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;C#&quot; style=&quot;background-color:#383838;color:#e6e1dc;&quot; class=&quot;language-C# &quot;&gt;&lt;code class=&quot;language-C#&quot; data-lang=&quot;C#&quot;&gt;&lt;span style=&quot;color:#cc7833;&quot;&gt;public &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#6e9cbe;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffc66d;&quot;&gt;gcd&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#6e9cbe;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#fd971f;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#6e9cbe;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#fd971f;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc7833;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d0d0ff;&quot;&gt;b &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc7833;&quot;&gt;== &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a5c261;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc7833;&quot;&gt;? &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d0d0ff;&quot;&gt;a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc7833;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span&gt;gcd(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d0d0ff;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d0d0ff;&quot;&gt;a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc7833;&quot;&gt;% &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d0d0ff;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;그리고 이게 그 유명한 유클리드 호제법이라는 것을 알게 되었다.&lt;&#x2F;p&gt;
&lt;p&gt;내가 알던 공약수 구하는 방법은 두 수의 약수들을 구하고 그 약수들을 곱하는 식이였다
예를 들어 252와 105의 공약수를 구하려면 252&#x2F;3=84, 105&#x2F;3=35 그리고 다시 84&#x2F;7=12, 35&#x2F;7=5, 12와 5는 공약수가 없기 때문에 3과 7이 252와 105의 공약수이고 3*7=21이 최대 공약수인 것이다.&lt;&#x2F;p&gt;
&lt;p&gt;참고 &lt;br &#x2F;&gt;
&lt;a href=&quot;https:&#x2F;&#x2F;www.khanacademy.org&#x2F;computing&#x2F;computer-science&#x2F;cryptography&#x2F;modarithmetic&#x2F;a&#x2F;the-euclidean-algorithm&quot;&gt;https:&#x2F;&#x2F;www.khanacademy.org&#x2F;computing&#x2F;computer-science&#x2F;cryptography&#x2F;modarithmetic&#x2F;a&#x2F;the-euclidean-algorithm&lt;&#x2F;a&gt;
&lt;a href=&quot;https:&#x2F;&#x2F;seunghyum.github.io&#x2F;algorithm&#x2F;Euclidean-algorithm&quot;&gt;https:&#x2F;&#x2F;seunghyum.github.io&#x2F;algorithm&#x2F;Euclidean-algorithm&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Permutation</title>
        <published>2023-05-29T00:00:00+00:00</published>
        <updated>2023-05-29T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://emptyfridge.dev/algorithm/permutation/"/>
        <id>https://emptyfridge.dev/algorithm/permutation/</id>
        
        <content type="html" xml:base="https://emptyfridge.dev/algorithm/permutation/">&lt;p&gt;몇일전에 leetcode 연습문제 441. Arranging Coins을 풀면서 n개 숫자를 더하는 공식을 보았다.
학교에서 1부터 100까지의 숫자를 더하는 문제를 배워본적이 있지 않은가? 가우스가 10살때 생각해냈다는 그 공식이다.
1부터 n까지의 합은 n(n+1)&#x2F;2 라는 공식으로 풀수 있다. 풀이는 인터넷에 많이 있으니까 굳이 내가 할 필요는 없는거 갈다.
근데 이 공식을 어디서 많이 본거 같다는 생각이 들었는데, 오늘 갑자기 n(n-1)&#x2F;2 라는 공식을 배운 기억이 떠올라서 구글링을 해보았다.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;frac-n-n-1-2-ngae-jungeseo-ganeunghan-johab&quot;&gt;$\frac{n(n-1)}{2}$ n개 중에서 가능한 조합&lt;&#x2F;h2&gt;
&lt;p&gt;구글링 해보니 Total number of subarry라고 나온다. 또는 the number of pairs you can form from an &lt;em&gt;n&lt;&#x2F;em&gt; element set 이라고 나온다. &lt;a href=&quot;https:&#x2F;&#x2F;math.stackexchange.com&#x2F;questions&#x2F;2214839&#x2F;exactly-how-does-the-equation-nn-1-2-determine-the-number-of-pairs-of-a-given&quot;&gt;링크&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;&#x2F;th&gt;&lt;th&gt;A&lt;&#x2F;th&gt;&lt;th&gt;B&lt;&#x2F;th&gt;&lt;th&gt;C&lt;&#x2F;th&gt;&lt;th&gt;D&lt;&#x2F;th&gt;&lt;th&gt;E&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;A&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;AB&lt;&#x2F;td&gt;&lt;td&gt;AC&lt;&#x2F;td&gt;&lt;td&gt;AD&lt;&#x2F;td&gt;&lt;td&gt;AE&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;B&lt;&#x2F;td&gt;&lt;td&gt;BA&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;BC&lt;&#x2F;td&gt;&lt;td&gt;BD&lt;&#x2F;td&gt;&lt;td&gt;BE&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;C&lt;&#x2F;td&gt;&lt;td&gt;CA&lt;&#x2F;td&gt;&lt;td&gt;CB&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;CD&lt;&#x2F;td&gt;&lt;td&gt;CE&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;D&lt;&#x2F;td&gt;&lt;td&gt;DA&lt;&#x2F;td&gt;&lt;td&gt;DB&lt;&#x2F;td&gt;&lt;td&gt;DC&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;DE&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;E&lt;&#x2F;td&gt;&lt;td&gt;EA&lt;&#x2F;td&gt;&lt;td&gt;EB&lt;&#x2F;td&gt;&lt;td&gt;EC&lt;&#x2F;td&gt;&lt;td&gt;ED&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;handshake문제다. n명이 중복되지 않고 악수를 한다고 생각해보자.
1명이 악수해야 할 숫자는 n명에서 자기 자신을 제외한 n-1번이다.
그럼 n명이 악수해야 할 숫자는 n(n-1)일까?
n(n-1)에는 중복이 포함되있다. AB-BA, AC-CA, AD-DA, AE-EA...&lt;&#x2F;p&gt;
&lt;h1 id=&quot;permutation&quot;&gt;Permutation&lt;&#x2F;h1&gt;
&lt;p&gt;조합문제를 공부하다 보니 수열도 다시 공부하게 되었다.
예전에 문제풀이 하다가 순열에 대해서 배웠는데 지금은 다 까먹었다. 그래서 다시 공부해본다
수열은 조합은 가끔 헷갈린다.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;n-r-ngaejungeseo-rgaereul-jungbogganeung-sunseoreul-goryeohaeseo-goreunda&quot;&gt;$n^r$ n개중에서 r개를 중복가능, 순서를 고려해서 고른다.&lt;&#x2F;h2&gt;
&lt;p&gt;ABC가 있는데 그중에서 중복 가능, 순서를 고려해서 3개를 고른다면,&lt;&#x2F;p&gt;
&lt;p&gt;AAA, AAB, AAC&lt;br &#x2F;&gt;
ABA, ABB, ABC&lt;br &#x2F;&gt;
ACA, ACB, ACC&lt;br &#x2F;&gt;
BAA, BAB, BAC&lt;br &#x2F;&gt;
BBA, BBB, BBC&lt;br &#x2F;&gt;
BCA, BCB, BCC&lt;br &#x2F;&gt;
CAA, CAB, CAC&lt;br &#x2F;&gt;
CBA, CBB, CBC&lt;br &#x2F;&gt;
CCA, CCB, CCC&lt;&#x2F;p&gt;
&lt;h2 id=&quot;frac-n-n-r-ngae-jungeseo-rgaereul-jungbogbulga-sunseoreul-goryeohaeseo-goreunda&quot;&gt;$\frac{n!}{(n-r)!}$ n개 중에서 r개를 중복불가, 순서를 고려해서 고른다.&lt;&#x2F;h2&gt;
&lt;p&gt;중복불가이기 때문에 한번 고를 때마다 그 전 숫자에서 1을 뺀 만큼의 선택지가 있다.
16개의 당구공 중에서 3개를 선택한다면, 첫번째는 16개 중에서 고르고, 그다음은 15개 중에서 고르고, 그 다음은 14개 중에서 고르게 된다. 16 x 15 x 14 = 3360 의 순열을 얻을 수 있다.
16 x 15 x 14 을 일반화한 공식을 얻기 위해서 factorial을 사용한다.
$\frac{16 * 15 * 14 * 13 * 12 * 11..3 * 2 * 1}{13 * 12 * 11 ... 3 * 2 * 1}$ =&amp;gt; $\frac{n!}{(n-r)!}$&lt;&#x2F;p&gt;
&lt;h2 id=&quot;combination&quot;&gt;Combination&lt;&#x2F;h2&gt;
&lt;h2 id=&quot;frac-n-r-n-r-johab-sunyeoleseo-sunseoreul-baejaehanda&quot;&gt;$\frac{n!}{r!(n-r)!}$ 조합, 순열에서 순서를 배재한다&lt;&#x2F;h2&gt;
&lt;p&gt;ABC나 CBA나 BCA나 A,B,C로 이루어져있기는 매한가지다. 그래서 A,B,C가 들어가면 그냥 ABC 조합이라고 한다.
위에서 $\frac{n!}{(n-r)!}$으로 중복불가하고 순서가 상관있는 순열을 얻었다. 여기서 순서에 상관없이 중복불가한 뽑기를 하면 바로 조합이 된다.
다시 당구공 예제로 돌아가보자. 16 x 15 x 14 = 3360의 순열이있다. 배치 가능한 숫자만큼 나눠주면 조합이 된다.
그렇다면 공3개는 몇가지로 배치가 가능한가? 3! 만큼 가능하다. 공 4개는 4! 만큼 가능하다. 그럼 r개는 r!.
3360순열을 3! 로 나눠주면 560이 나온다.&lt;&#x2F;p&gt;
</content>
        
    </entry>
</feed>
